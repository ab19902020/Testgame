<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Script Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for a more integrated look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="app-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <script>
        // --- Root Element ---
        const appContainer = document.getElementById('app-container');

        // --- State Management ---
        let state = {
            view: 'home',
            writingStyle: 'The Investigator',
            aiImageStyle: 'ultra-realistic',
            selectedCategory: null,
            selectedGenre: null,
            suggestions: [],
            customTopic: "",
            selectedStory: null,
            script: null,
            suggestedStyles: [],
            loadingMessage: null,
            error: null,
            editingState: null, // { scene_number, imageIndex }
            optionsVisible: null, // { scene_number, imageIndex }
            editedPrompt: "",
            pdfScriptsLoaded: false,
        };

        // --- Data ---
        const topics = {
            'Military History': ['Forgotten Battles', 'Special Forces Operations', 'Sieges & Last Stands', 'Military Intelligence', 'Revolutionary Wars', 'Ancient Warfare'],
            'Science & Technology': ['Space Race Secrets', 'Medical Breakthroughs', 'Famous Inventions', 'Archaeological Finds', 'Cyber Warfare Origins', 'Failed Experiments'],
            'Disasters & Survival': ['Mountaineering Disasters', 'Polar Expeditions', 'Lost at Sea', 'Volcanic Eruptions', 'Nuclear Incidents', 'Wilderness Survival'],
            'Ancient Worlds': ['Ancient Egypt Mysteries', 'Roman Engineering', 'Lost Cities', 'Viking Sagas', 'Gladiatorial Games', 'Mythological Battles'],
            'Crime & Espionage': ['Famous Art Heists', 'Unsolved Mysteries', 'Cold Cases', 'Great Escapes', 'Cold War Spies', 'Corporate Espionage'],
            'True Crime (18+)': ['Serial Killers', 'Cults & Fanaticism', 'Forensic Breakthroughs', 'Organized Crime Syndicates', 'Heists Gone Wrong', 'Art Forgeries'],
            'Conspiracies & The Unexplained': ['Historical Conspiracies', 'Alien Encounters & UFOs', 'Paranormal Events', 'Cryptids & Monsters', 'Secret Societies', 'Government Cover-ups'],
            'Psychology & The Mind': ['Famous Psychological Experiments', 'Cases of Mass Hysteria', 'Feral Children', 'Memory & Amnesia', 'Propaganda & Mind Control'],
            'Exploration & Adventure': ['Age of Discovery Voyages', 'Deep Sea Exploration', 'Lost Expeditions', 'First Ascents', 'Around the World Journeys'],
            'Art & Culture': ['Stolen Masterpieces', 'Legendary Concerts', 'Literary Hoaxes', 'Rivalries in Art', 'Forbidden Films & Books'],
            'Business & Innovation': ['The Dot-com Bubble', 'Legendary Entrepreneurs', 'Hostile Takeovers', 'Product Wars (Coke vs Pepsi)', 'Industrial Espionage'],
            'Myths & Folklore': ['Creatures of Legend', 'Mythical Places', 'Ancient Epics', 'Urban Legends', 'Creation Myths'],
            'Social & Political': ['Civil Rights Stories', 'Famous Protests', 'Utopian Communities', 'Political Scandals', 'Assassination Plots'],
            'The Wild West': ['Famous Outlaws', 'Legendary Lawmen', 'Gold Rush Stories', 'Native American Conflicts', 'Cattle Drives'],
            'The Golden Age of Piracy': ['Famous Pirates', 'Life Aboard a Pirate Ship', 'The Pirate Code', 'Lost Pirate Treasure', 'The War Against Piracy'],
            'The Darkest Secrets': ['Jeffrey Epstein & Elite Pedophile Networks', 'CIA Mind Control Programs (MKUltra)', 'Deep State Political Assassinations (JFK, MLK)', 'Bilderberg Group & Globalist Agendas', 'Big Pharma Cover-ups & Vaccine Injuries', '9/11 Inside Job Evidence', 'The Bohemian Grove & Elite Rituals', 'Federal Reserve & Economic Manipulation', 'COVID-19 Lab Leak Theory & Suppression', 'UFO Reverse Engineering & Cover-ups']
        };

        const writingStyles = {
            'The Investigator': 'A calm, introspective, and poetic style focusing on the human element.',
            'The Conspiracist': 'A conversational, humorous, and skeptical voice that dives deep into mysteries.',
            'The Forensic Analyst': 'A precise, detailed, and objective tone that meticulously pieces together evidence.',
            'The Deep-Diver': 'An enthusiastic and passionate style that connects many disparate points into a grand theory.',
            'The Tactician': 'An analytical, objective voice, like a military strategist, focusing on tactics and strategy.',
            'The Skald': 'A dramatic, epic voice, like a Viking saga-teller, using powerful, archaic language.',
            'The Chronicler': 'A formal, authoritative voice, like a classic BBC documentarian, focusing on the grand sweep of history.',
            'The Declassifier': 'A direct, factual, and authoritative voice that presents information like a declassified intelligence briefing.',
            'The Biographer': 'An intimate, personal style that focuses on the life and psychology of a single individual.',
            'The Historian': 'A broad, contextual style that connects events to the larger sweep of history.',
            'The Thriller Author': 'A fast-paced, suspenseful voice that uses cliffhangers and a sense of urgency.',
            'The Gonzo Journalist': 'A highly personal, subjective, and often humorous first-person perspective.',
            'The Hard Truth Exposer': 'A aggressive, unfiltered, and fearless style that exposes corruption without holding back. Uses direct, blunt language and treats all official narratives as suspect until proven otherwise. Focuses on motive, opportunity, and the silencing of whistleblowers. Leaves no room for doubt about criminal conspiracies at the highest levels.'
        };

        // --- State Updater ---
        function setState(newState) {
            Object.assign(state, newState);
            render();
        }

        // --- Core Functions ---
        function resetApp() {
            setState({
                view: 'home',
                selectedCategory: null,
                selectedGenre: null,
                suggestions: [],
                customTopic: "",
                selectedStory: null,
                script: null,
                error: null,
                loadingMessage: null
            });
        }

        async function handleStorySelect(storyIndex) {
            const story = state.suggestions[storyIndex];
            setState({ selectedStory: story, view: 'final-selection', loadingMessage: 'Analyzing story for style suggestions...' });
            
            try {
                const styleNames = Object.keys(writingStyles).join(', ');
                const prompt = `Analyze the following story summary: "${story.summary}". Based on its content and tone, which of the following writing styles would be most effective for a YouTube documentary? [${styleNames}]. Return your top 3 recommendations as a JSON array of strings.`;
                const result = await generateText(prompt, true, { type: "ARRAY", items: { type: "STRING" } });
                const recommended = JSON.parse(result);
                
                const newState = { suggestedStyles: recommended };
                if (recommended.length > 0) {
                    newState.writingStyle = recommended[0];
                }
                setState(newState);
            } catch (e) {
                console.error("Failed to get style suggestions:", e);
                setState({ suggestedStyles: [], error: e.message });
            } finally {
                setState({ loadingMessage: null });
            }
        }

        async function fetchStorySuggestions(category, genre) {
            setState({ loadingMessage: 'Finding story ideas...', error: null, suggestions: [] });
            try {
                const prompt = `Based on the category "${category}" and genre "${genre}", generate three compelling and varied true story ideas for a YouTube video. The suggestions can include both well-known and obscure topics, but each should have a clear, engaging angle. Return as a JSON object with a "suggestions" array, each with a "title" and a "summary".`;
                const result = await generateText(prompt, true, { type: "OBJECT", properties: { suggestions: { type: "ARRAY", items: { type: "OBJECT", properties: { title: { type: "STRING" }, summary: { type: "STRING" } }, required: ["title", "summary"] } } }, required: ["suggestions"] });
                setState({ suggestions: JSON.parse(result).suggestions, view: 'guided-suggestions' });
            } catch (e) {
                setState({ error: e.message || 'Failed to generate story suggestions. Please try again.' });
            } finally {
                setState({ loadingMessage: null });
            }
        }

        async function handleCustomTopicSubmit() {
            if (!state.customTopic) return;
            setState({ loadingMessage: 'Researching your topic...', error: null });
            try {
                const prompt = `Research the topic: "${state.customTopic}". Based on your findings, generate three distinct and compelling true story ideas for a YouTube video. Each idea should present a different angle or focus. Return as a JSON object with a "suggestions" array, each with a "title" and a "summary".`;
                const result = await generateText(prompt, true, { type: "OBJECT", properties: { suggestions: { type: "ARRAY", items: { type: "OBJECT", properties: { title: { type: "STRING" }, summary: { type: "STRING" } }, required: ["title", "summary"] } } }, required: ["suggestions"] });
                setState({ suggestions: JSON.parse(result).suggestions, view: 'guided-suggestions' });
            } catch (e) {
                setState({ error: e.message || 'The AI could not find enough information on that topic.' });
            } finally {
                setState({ loadingMessage: null });
            }
        }

        function getScriptPrompt() {
             const base = `Create a script for a 20-minute YouTube documentary about: "${state.selectedStory.title}: ${state.selectedStory.summary}". The script must be a world-class, deep-dive narrative. CRITICAL OUTPUT FORMAT: Output a JSON object with a 'title' and a 'scenes' array. Each scene object MUST contain: 1. 'scene_number': (Number). 2. 'description_full': (String) A complete, vivid description of the entire scene's action and mood. 3. 'description_part_1': (String) A concrete, visual description for the FIRST HALF of the scene. Do NOT use non-visual terms like "montage". 4. 'description_part_2': (String) A concrete, visual description for the SECOND HALF of the scene. 5. 'dialogue': (String) The narrator's lines for the entire scene.`;
            switch (state.writingStyle) {
                case 'The Conspiracist': return `${base} WRITING STYLE: Adopt the persona of a witty, slightly sarcastic, and deeply curious investigator, like the host of "The Why Files". The tone should be conversational and humorous, but grounded in detailed research. Weave in facts, dates, and data points, but always with an eye for the strange and unexplained. Connect seemingly unrelated events and raise compelling "what if" questions. End scenes on cliffhangers that make the viewer question everything.`;
                case 'The Forensic Analyst': return `${base} WRITING STYLE: Adopt the persona of a forensic analyst or historian, like the narrator of "LEMMiNO". The tone must be precise, objective, and almost academic, but utterly compelling. Focus on meticulously piecing together evidence, presenting facts and timelines in a clear, logical sequence. Build the narrative through the careful revelation of information, creating a sense of a complex puzzle being solved. The language should be sophisticated and the pacing deliberate.`;
                case 'The Deep-Diver': return `${base} WRITING STYLE: Adopt the persona of an enthusiastic, passionate deep-diver, like the host of "Wendigoon". The tone should be that of a friend excitedly explaining a fascinating, complex topic. Connect many disparate points, historical facts, and obscure details into a grand, all-encompassing theory or narrative. Use an "iceberg" structure, starting with the known facts and progressively delving into more obscure and speculative layers.`;
                case 'The Tactician': return `${base} WRITING STYLE: Adopt the persona of a military strategist or historian, like the narrator of "The Operations Room". The tone must be analytical, objective, and highly detailed. Focus on the tactical and strategic elements of the story: troop movements, equipment specifics, command decisions, and the chain of events. Use precise, clear language, avoiding overly emotional or speculative phrasing. The narrative should be driven by the cause-and-effect of key decisions.`;
                case 'The Skald': return `${base} WRITING STYLE: Adopt the persona of a Norse skald or saga-teller, inspired by channels like "Dr. Jackson Crawford". The tone should be epic, dramatic, and slightly archaic. Use powerful, evocative language that speaks of honor, fate, and the harsh realities of the Viking age. Focus on the deeds of legendary figures, the clash of cultures, and the mythic undertones of historical events.`;
                case 'The Chronicler': return `${base} WRITING STYLE: Adopt the persona of a formal historian or chronicler, in the style of a classic BBC documentary. The tone must be authoritative, clear, and dignified. Focus on the grand sweep of history, lineage, political intrigue, and the chronological unfolding of events. The narrative should be well-structured and present a comprehensive, balanced view of the subject.`;
                case 'The Declassifier': return `${base} WRITING STYLE: Adopt the persona of an intelligence analyst briefing a superior, in the style of the YouTube channel "Blackfiles". The tone is direct, factual, and authoritative. Present information clearly and concisely, focusing on "what exactly was happening." The narrative should be structured as a chronological report, revealing information as it would appear in a declassified document.`;
                case 'The Biographer': return `${base} WRITING STYLE: Adopt the persona of an intimate biographer. The narrative should focus deeply on the life, motivations, and psychology of a key individual in the story. The tone is personal and empathetic, exploring the subject's inner world and how their character shaped the events around them.`;
                case 'The Historian': return `${base} WRITING STYLE: Adopt the persona of a university historian. The tone is academic but accessible, focused on placing the story within its broader historical context. Explain the "why" behind the "what," connecting the events to the social, political, and economic forces of the era.`;
                case 'The Thriller Author': return `${base} WRITING STYLE: Adopt the persona of a thriller novelist like Tom Clancy or Lee Child. The tone is fast-paced, tense, and action-oriented. Use short, punchy sentences and build suspense with cliffhangers and dramatic reveals. Focus on the operational details and the high stakes of the situation.`;
                case 'The Gonzo Journalist': return `${base} WRITING STYLE: Adopt the persona of a gonzo journalist like Hunter S. Thompson. The tone is highly personal, subjective, satirical, and often humorous. Write in the first person, injecting your own feelings and exaggerated reactions into the narrative. The style should be energetic, chaotic, and filled with vivid, unconventional descriptions.`;
                case 'The Hard Truth Exposer': return `${base} WRITING STYLE: Adopt the persona of an aggressive, fearless investigative journalist who exposes high-level corruption and cover-ups. The tone is urgent, angry, and defiant. Do not soften language or present "both sides" of a criminal conspiracy. State facts as definitive truths. Focus on: 1. MOTIVE (Why the powerful would commit these acts). 2. OPPORTUNITY (How systems were exploited). 3. THE SUPPRESSION OF EVIDENCE (Whistleblower deaths, media blackouts, official obfuscation). Explicitly name names and organizations. Treat official narratives as deliberate lies. This is not a theory; it is an exposé of confirmed criminality at the highest levels of power.`;
                case 'The Investigator': default: return `${base} WRITING STYLE: Act as a master storyteller in the style of the YouTube channel "The Fern". The tone should be calm, introspective, deeply human, and slightly melancholic. Center the narrative on the personal, human elements of the story. Use a deliberate, thoughtful pace. The language should be poetic, metaphorical, and evocative, but always clear and grounded in fact. Avoid sensationalism. Start with a small, seemingly insignificant detail and expand outwards to the larger historical context.`;
            }
        }
        
        async function generateContent() {
            if (!state.selectedStory) return;
            setState({ view: 'script', loadingMessage: 'Crafting your narrative...', error: null, script: null });
            
            let scriptResult;
            let parsedScript;

            try {
                const scriptPrompt = getScriptPrompt();
                scriptResult = await generateText(scriptPrompt, true, { type: "OBJECT", properties: { title: { type: "STRING" }, scenes: { type: "ARRAY", items: { type: "OBJECT", properties: { scene_number: { type: "NUMBER" }, description_full: { type: "STRING" }, description_part_1: { type: "STRING" }, description_part_2: { type: "STRING" }, dialogue: { type: "STRING" } }, required: ["scene_number", "description_full", "description_part_1", "description_part_2", "dialogue"] } } }, required: ["title", "scenes"] });
                
                try {
                    parsedScript = JSON.parse(scriptResult);
                } catch (parseError) {
                    console.error("Failed to parse script JSON:", parseError);
                    console.error("Received text from API:", scriptResult);
                    throw new Error("The AI returned an invalid script format. Please try a different story or style.");
                }

                parsedScript.scenes = parsedScript.scenes.map(scene => ({...scene, media: { ai1: 'loading', ai2: 'loading' }}));
                setState({ script: parsedScript });

                setTimeout(() => {
                    const scriptContainer = document.getElementById('script-container');
                    if (scriptContainer) {
                        scriptContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);

                for (let i = 0; i < parsedScript.scenes.length; i++) {
                    setState({ loadingMessage: `Generating 2 images for Scene ${i + 1}...` });
                    const scene = parsedScript.scenes[i];
                    
                    const aiImagePromise1 = generateImageWithRetry(scene.description_part_1);
                    const aiImagePromise2 = generateImageWithRetry(scene.description_part_2);

                    const [aiImageResult1, aiImageResult2] = await Promise.all([aiImagePromise1, aiImagePromise2]);
                    
                    const currentScriptState = state.script;
                    if(currentScriptState) { // Ensure script state hasn't been cleared
                        const updatedScenes = [...currentScriptState.scenes];
                        updatedScenes[i].media = { ai1: aiImageResult1, ai2: aiImageResult2 };
                        setState({ script: { ...currentScriptState, scenes: updatedScenes } });
                    }
                }
            } catch (e) {
                console.error(e);
                setState({ error: e.message || 'An error occurred during script generation. Please try again.' });
            } finally {
                setState({ loadingMessage: null });
            }
        }

        async function handleRegenerateImage(scene_number, imageIndex, promptOverride = null) {
            setState({ loadingMessage: `Regenerating image ${imageIndex} for Scene ${scene_number}...` });
            const scene = state.script.scenes.find(s => s.scene_number === scene_number);
            try {
                const description = promptOverride || (imageIndex === 1 ? scene.description_part_1 : scene.description_part_2);
                const imageUrl = await generateImageWithRetry(description);
                
                const updatedScript = { ...state.script };
                updatedScript.scenes = updatedScript.scenes.map(s => {
                    if (s.scene_number === scene_number) {
                        const newMedia = {...s.media};
                        newMedia[`ai${imageIndex}`] = imageUrl;
                        return {...s, media: newMedia};
                    }
                    return s;
                });
                setState({ script: updatedScript });

            } catch (e) {
                setState({ error: e.message || `Failed to regenerate image for scene ${scene_number}.` });
            } finally {
                setState({ loadingMessage: null, editingState: null });
            }
        }

        // --- PDF Generation ---
        async function saveAsPDF() {
            if (!state.script || !window.jspdf) return;
            setState({ loadingMessage: 'Preparing PDF...' });
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'pt', 'a4');
            const margin = 40,
                pageWidth = doc.internal.pageSize.getWidth(),
                usableWidth = pageWidth - margin * 2;
            let y = margin;

            doc.setFontSize(24).text(state.script.title, pageWidth / 2, y, { align: 'center' });
            y += 40;

            for (const scene of state.script.scenes) {
                if (y > doc.internal.pageSize.getHeight() - 300) { // Check if space is enough
                    doc.addPage();
                    y = margin;
                }
                doc.setFontSize(14).setFont(undefined, 'bold').text(`Scene ${scene.scene_number}`, margin, y);
                y += 20;

                doc.setFontSize(10).setFont(undefined, 'italic');
                const descLines = doc.splitTextToSize(`Description: ${scene.description_full}`, usableWidth);
                doc.text(descLines, margin, y);
                y += descLines.length * 12 + 10;
                
                doc.setFontSize(10).setFont(undefined, 'normal');
                const dialogueLines = doc.splitTextToSize(`Narration: ${scene.dialogue}`, usableWidth);
                doc.text(dialogueLines, margin, y);
                y += dialogueLines.length * 12 + 20;

                const addImageToPdf = async (element) => {
                    if (element) {
                        try {
                            const canvas = await html2canvas(element, { useCORS: true, logging: false });
                            const imgData = canvas.toDataURL('image/png');
                            const imgProps = doc.getImageProperties(imgData);
                            const imgHeight = (imgProps.height * usableWidth) / imgProps.width;
                            if (y + imgHeight > doc.internal.pageSize.getHeight() - margin) {
                                doc.addPage();
                                y = margin;
                            }
                            doc.addImage(imgData, 'PNG', margin, y, usableWidth, imgHeight);
                            y += imgHeight + 20;
                        } catch (err) {
                            console.error("PDF image capture error:", err);
                        }
                    }
                };

                await addImageToPdf(document.getElementById(`scene-media-ai1-${scene.scene_number}`));
                await addImageToPdf(document.getElementById(`scene-media-ai2-${scene.scene_number}`));
            }
            doc.save(`${state.script.title.replace(/ /g, '_')}.pdf`);
            setState({ loadingMessage: null });
        }
        
        // --- Download All Images ---
        function saveAllImages() {
            if (!state.script) return;
            setState({ loadingMessage: 'Preparing images for download...' });
            state.script.scenes.forEach((scene) => {
                [1, 2].forEach(imgIndex => {
                    const imgData = scene.media[`ai${imgIndex}`];
                    if (imgData && !imgData.startsWith('https://placehold.co') && imgData !== 'loading') {
                        const link = document.createElement('a');
                        link.href = imgData;
                        link.download = `${state.script.title.replace(/ /g, '_')}_Scene_${scene.scene_number}_Image_${imgIndex}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                });
            });
            setState({ loadingMessage: null });
        }


        // --- API Helpers ---
        async function generateText(prompt, isJson = false, schema = null) {
            const apiKey = ""; // Use the embedded, free API key provided by the platform.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            if (isJson && schema) payload.generationConfig = { responseMimeType: "application/json", responseSchema: schema };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API call failed: ${response.status}. The platform's API service may be temporarily unavailable.`);
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
            throw new Error('Unexpected API response format.');
        }

        async function generateImageWithRetry(description) {
            const negativePrompt = " Under no circumstances should the image depict a narrator, a person speaking into a microphone, or a podcast-style setting. Focus only on the historical scene itself.";
            let stylePrompt = "CRITICAL COMMAND: The final image MUST be generated with a cinematic 16:9 aspect ratio (e.g., 1920x1080 pixels). This is a mandatory, non-negotiable requirement. A photorealistic, cinematic still from a historical drama film. Moody, atmospheric lighting (e.g., chiaroscuro, volumetric light), shallow depth of field, film grain. Focus on gritty realism and emotional weight. Maintain this exact visual style consistently across all images. DO NOT create a montage, split-screen, or comic book panel layout. The output must be ONE image.";
            if (state.aiImageStyle === 'animated') {
                stylePrompt = "CRITICAL COMMAND: The final image MUST be generated with a cinematic 16:9 aspect ratio (e.g., 1920x1080 pixels). This is a mandatory, non-negotiable requirement. CRITICAL Art Style: A mature, gritty, 3D animation style with a distinct cel-shaded, painterly look. The style is serious and realistic, exactly like the video game series 'The Walking Dead' by Telltale Games or the series 'Arcane'. The image MUST have dramatic, high-contrast lighting, visible ink lines on characters, and a serious, non-cartoonish tone. ABSOLUTELY NO PIXAR, DISNEY, OR FAMILY-FRIENDLY STYLES. Maintain this exact Telltale/Arcane visual style consistently across all images. DO NOT create a montage, split-screen, or comic book panel layout. The output must be ONE image.";
            } else if (state.aiImageStyle === 'graphic-novel') {
                stylePrompt = "CRITICAL COMMAND: The final image MUST be generated with a cinematic 16:9 aspect ratio (e.g., 1920x1080 pixels). This is a mandatory, non-negotiable requirement. A high-quality, realistic historical graphic novel style. The image must have strong, clean ink lines, realistic human proportions, and detailed backgrounds. The lighting should be cinematic and moody, creating a sense of drama. The color palette should be sophisticated and grounded in realism. This is a serious, mature comic book style, NOT a simplistic or stylized cartoon. Maintain this exact visual style consistently across all images. DO NOT create a montage, split-screen, or comic book panel layout. The output must be ONE image.";
            }
            const fullPrompt = `${stylePrompt} The scene to depict is: "${description}". ${negativePrompt}`;

            for (let i = 0; i < 3; i++) {
                try { return await generateImage(fullPrompt); }
                catch (error) {
                    if (i === 2) {
                         console.error("Image generation failed after 3 retries:", error);
                         return `https://placehold.co/1280x720/1F2D37/EAB308?text=Generation+Failed`;
                    }
                    await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i)));
                }
            }
        }

        async function generateImage(prompt) {
            const apiKey = ""; // Use the embedded, free API key provided by the platform.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
            const payload = { instances: [{ prompt }], parameters: { "sampleCount": 1, "aspect_ratio": "16:9" } };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API call failed: ${response.status}. The platform's API service may be temporarily unavailable.`);
            const result = await response.json();
            if (result.predictions?.[0]?.bytesBase64Encoded) return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
            throw new Error('Image generation failed.');
        }
        
        // --- Render Logic ---
        function render() {
            let content = '';

            const header = `
                <header class="text-center mb-8">
                    <h1 class="text-4xl md:text-5xl font-bold text-cyan-400">AI Video Script Generator</h1>
                    <p class="text-gray-400 mt-2">World-Class Storytelling & Visuals</p>
                    <nav class="mt-4 flex justify-center gap-4">
                        <button onclick="resetApp()" class="bg-gray-700 hover:bg-cyan-600 px-4 py-2 rounded-md transition-colors">New Project / Home</button>
                    </nav>
                </header>
            `;

            const loadingIndicator = state.loadingMessage ? `
                <div class="fixed top-0 left-0 w-full h-16 bg-gray-800/90 backdrop-blur-sm flex items-center justify-center z-50 shadow-lg">
                    <div class="w-6 h-6 border-4 border-dashed rounded-full animate-spin border-cyan-400"></div>
                    <p class="ml-4 text-lg text-cyan-300">${state.loadingMessage}</p>
                </div>
            ` : '';
            
            const errorDisplay = state.error ? `
                <div class="bg-red-500/20 border border-red-500 text-red-300 px-4 py-3 rounded-lg text-center mb-8 cursor-pointer" onclick="setState({error: null})">
                    ${state.error} (click to dismiss)
                </div>
            ` : '';

            let viewContent = '';
            switch(state.view) {
                case 'home':
                    viewContent = `
                        <div class="max-w-4xl mx-auto bg-gray-800 p-6 rounded-lg shadow-xl">
                            <h2 class="text-2xl font-semibold mb-4 text-center">Choose Your Method</h2>
                            <div class="grid md:grid-cols-2 gap-8">
                                <div class="bg-gray-700 p-6 rounded-lg text-center cursor-pointer hover:ring-2 ring-cyan-500 transition-all" onclick="setState({view: 'guided-category'})">
                                    <h2 class="text-2xl font-bold text-cyan-400">Guided Creation</h2>
                                    <p class="mt-2 text-gray-400">Get unique story ideas.</p>
                                </div>
                                <div class="bg-gray-700 p-6 rounded-lg text-center cursor-pointer hover:ring-2 ring-green-500 transition-all" onclick="setState({view: 'custom'})">
                                    <h2 class="text-2xl font-bold text-green-400">Custom Topic</h2>
                                    <p class="mt-2 text-gray-400">Enter your own subject.</p>
                                </div>
                            </div>
                        </div>`;
                    break;
                case 'guided-category':
                    viewContent = `
                        <div class="max-w-6xl mx-auto bg-gray-800 p-6 rounded-lg shadow-xl">
                            <h2 class="text-2xl font-semibold mb-4 text-center">Step 1: Choose a Category</h2>
                            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                ${Object.keys(topics).map(cat => `
                                    <button onclick="setState({selectedCategory: '${cat}', view: 'guided-genre'})" class="p-4 bg-gray-700 rounded-md text-lg text-cyan-300 hover:bg-cyan-800 transition-colors">${cat}</button>
                                `).join('')}
                            </div>
                        </div>`;
                    break;
                case 'guided-genre':
                    viewContent = `
                        <div class="max-w-6xl mx-auto bg-gray-800 p-6 rounded-lg shadow-xl">
                            <h2 class="text-2xl font-semibold mb-4 text-center">Step 2: Select a Genre in "${state.selectedCategory}"</h2>
                            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
                                ${topics[state.selectedCategory].map(genre => `
                                    <button onclick="setState({selectedGenre: '${genre}'}); fetchStorySuggestions('${state.selectedCategory}', '${genre}');" class="p-4 bg-gray-700 rounded-md text-green-300 hover:bg-green-800 transition-colors">${genre}</button>
                                `).join('')}
                            </div>
                            <button onclick="setState({view: 'guided-category'})" class="mt-6 text-gray-400 hover:text-white">← Back to Categories</button>
                        </div>`;
                    break;
                case 'guided-suggestions':
                     viewContent = `
                        <div class="max-w-4xl mx-auto bg-gray-800 p-6 rounded-lg shadow-xl">
                            <h2 class="text-2xl font-semibold mb-4 text-center">Step 3: Choose a Story</h2>
                            <div class="space-y-4">
                                ${state.suggestions.map((story, index) => `
                                    <div onclick="handleStorySelect(${index})" class="p-4 bg-gray-700 rounded-lg cursor-pointer hover:ring-2 ring-purple-500 transition-all">
                                        <h3 class="font-bold text-lg text-purple-300">${story.title}</h3>
                                        <p class="text-gray-400 text-sm mt-1">${story.summary}</p>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="flex justify-center gap-4 mt-6">
                                <button onclick="setState({view: 'guided-genre'})" class="text-gray-400 hover:text-white">← Back to Genres</button>
                                <button onclick="fetchStorySuggestions('${state.selectedCategory}', '${state.selectedGenre}')" ${state.loadingMessage ? 'disabled' : ''} class="bg-cyan-600 text-white px-4 py-2 rounded-md hover:bg-cyan-500 disabled:bg-gray-600">Get New Ideas</button>
                            </div>
                        </div>`;
                    break;
                case 'custom':
                    viewContent = `
                        <div class="max-w-2xl mx-auto bg-gray-800 p-6 rounded-lg shadow-xl">
                            <h2 class="text-2xl font-semibold mb-4 text-center">Enter a Custom Topic</h2>
                            <p class="text-center text-gray-400 mb-4">Enter a person, event, or concept. The AI will research it and generate story angles.</p>
                            <textarea id="custom-topic-input" class="w-full bg-gray-900 text-white p-2 rounded-md h-24" placeholder="e.g., 'The Great Emu War' or 'Hedy Lamarr's inventions'">${state.customTopic}</textarea>
                            <button onclick="setState({customTopic: document.getElementById('custom-topic-input').value}); handleCustomTopicSubmit();" ${state.loadingMessage ? 'disabled' : ''} class="mt-4 w-full bg-green-500 text-white px-8 py-3 text-lg font-bold rounded-lg shadow-lg hover:bg-green-600 disabled:bg-gray-600">Find Story Angles</button>
                        </div>`;
                    break;
                case 'final-selection':
                    const suggestedOptions = state.suggestedStyles.map(s => `<option value="${s}">${s}</option>`).join('');
                    const allOptions = Object.keys(writingStyles).map(s => `<option value="${s}">${s}</option>`).join('');
                    viewContent = `
                        <div class="max-w-4xl mx-auto text-center">
                            <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                                <h2 class="text-3xl font-bold">${state.selectedStory.title}</h2>
                                <p class="text-gray-400 mt-2 mb-6">${state.selectedStory.summary}</p>
                                <div class="bg-gray-900/50 p-6 rounded-lg text-left grid md:grid-cols-2 gap-6">
                                    <div>
                                        <label class="block text-lg font-semibold text-cyan-300 mb-2">Narrator Style</label>
                                        <select id="writing-style-select" class="w-full bg-gray-700 p-3 rounded-md">
                                            ${state.suggestedStyles.length > 0 ? `<optgroup label="Recommended">${suggestedOptions}</optgroup>` : ''}
                                            <optgroup label="All Styles">${allOptions}</optgroup>
                                        </select>
                                        <p class="text-gray-400 text-sm mt-2" id="writing-style-description">${writingStyles[state.writingStyle]}</p>
                                    </div>
                                    <div>
                                        <label class="block text-lg font-semibold text-green-300 mb-2">AI Image Style</label>
                                        <select id="ai-image-style-select" class="w-full bg-gray-700 p-3 rounded-md">
                                            <option value="ultra-realistic">Ultra-Realistic Cinematic</option>
                                            <option value="animated">Animated (Telltale/Arcane Style)</option>
                                            <option value="graphic-novel">Graphic Novel</option>
                                        </select>
                                        <p class="text-gray-400 text-sm mt-2" id="ai-image-style-description">
                                            ${state.aiImageStyle === 'ultra-realistic' ? 'Photorealistic stills from a historical drama film.' : ''}
                                            ${state.aiImageStyle === 'animated' ? 'Mature, gritty 3D animation with a painterly look.' : ''}
                                            ${state.aiImageStyle === 'graphic-novel' ? 'High-quality, realistic historical comic book art.' : ''}
                                        </p>
                                    </div>
                                </div>
                                <button onclick="generateContent()" ${state.loadingMessage ? 'disabled' : ''} class="mt-8 w-full bg-purple-600 text-white px-8 py-4 text-xl font-bold rounded-lg shadow-lg hover:bg-purple-700 disabled:bg-gray-600 transition-transform transform hover:scale-105">
                                    Generate Script & Visuals
                                </button>
                                <button onclick="setState({view: 'guided-suggestions'})" class="mt-4 text-gray-400 hover:text-white">← Back to Story Suggestions</button>
                            </div>
                        </div>`;
                    break;
                case 'script':
                    if (state.script) {
                        viewContent = `
                        <div id="script-container" class="max-w-5xl mx-auto">
                            <div class="bg-gray-800 p-6 rounded-lg mb-8 text-center shadow-lg">
                                <h2 class="text-3xl md:text-4xl font-bold text-cyan-300">${state.script.title}</h2>
                                <div class="mt-6 flex flex-wrap justify-center gap-4">
                                    <button onclick="saveAsPDF()" ${!window.jspdf || state.loadingMessage ? 'disabled' : ''} class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-600">Download as PDF</button>
                                    <button onclick="saveAllImages()" ${state.loadingMessage ? 'disabled' : ''} class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-600">Download All Images</button>
                                </div>
                            </div>

                            <div class="space-y-12">
                                ${state.script.scenes.map(scene => `
                                    <div class="bg-gray-800/50 p-4 md:p-6 rounded-lg shadow-xl">
                                        <h3 class="text-2xl font-bold text-purple-300 border-b-2 border-purple-500/30 pb-2 mb-4">Scene ${scene.scene_number}</h3>
                                        <div class="grid md:grid-cols-5 gap-6">
                                            <div class="md:col-span-2 space-y-4">
                                                ${[1, 2].map(imageIndex => `
                                                    <div class="relative group">
                                                    ${scene.media[`ai${imageIndex}`] === 'loading' ? `
                                                        <div class="aspect-video bg-gray-700 rounded-lg flex items-center justify-center"><div class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-cyan-400"></div></div>
                                                    ` : `
                                                        <img id="scene-media-ai${imageIndex}-${scene.scene_number}" src="${scene.media[`ai${imageIndex}`]}" alt="AI visual for scene ${scene.scene_number}, part ${imageIndex}" class="w-full aspect-video rounded-lg object-cover" crossOrigin="anonymous" />
                                                        <div class="absolute top-2 right-2">
                                                            <button onclick="setState({ optionsVisible: (state.optionsVisible && state.optionsVisible.scene_number === ${scene.scene_number} && state.optionsVisible.imageIndex === ${imageIndex}) ? null : { scene_number: ${scene.scene_number}, imageIndex: ${imageIndex} } })" class="bg-black/50 hover:bg-black/80 text-white rounded-full p-2 focus:outline-none">
                                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>
                                                            </button>
                                                            ${(state.optionsVisible?.scene_number === scene.scene_number && state.optionsVisible?.imageIndex === imageIndex) ? `
                                                            <div class="absolute right-0 mt-2 w-48 bg-gray-900 border border-gray-700 rounded-md shadow-lg z-20">
                                                                <button onclick="handleRegenerateImage(${scene.scene_number}, ${imageIndex}); setState({optionsVisible: null});" class="block w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">Regenerate</button>
                                                                <button onclick="setState({ editingState: { scene_number: ${scene.scene_number}, imageIndex: ${imageIndex} }, editedPrompt: ${JSON.stringify(imageIndex === 1 ? scene.description_part_1 : scene.description_part_2)}, optionsVisible: null });" class="block w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">Edit & Regenerate</button>
                                                            </div>
                                                            ` : ''}
                                                        </div>
                                                    `}
                                                    ${(state.editingState?.scene_number === scene.scene_number && state.editingState?.imageIndex === imageIndex) ? `
                                                    <div class="absolute inset-0 bg-black/80 p-4 flex flex-col rounded-lg z-10">
                                                        <textarea id="edit-prompt-${scene.scene_number}-${imageIndex}" class="w-full flex-grow bg-gray-800 text-white p-2 rounded-md text-sm">${state.editedPrompt}</textarea>
                                                        <div class="flex justify-end gap-2 mt-2">
                                                            <button onclick="setState({editingState: null})" class="bg-gray-600 px-3 py-1 rounded-md text-sm">Cancel</button>
                                                            <button onclick="handleRegenerateImage(${scene.scene_number}, ${imageIndex}, document.getElementById('edit-prompt-${scene.scene_number}-${imageIndex}').value)" class="bg-green-600 px-3 py-1 rounded-md text-sm">Regenerate</button>
                                                        </div>
                                                    </div>
                                                    ` : ''}
                                                    </div>
                                                `).join('')}
                                            </div>
                                            <div class="md:col-span-3">
                                                <div class="bg-gray-900/70 p-4 rounded-lg">
                                                    <h4 class="font-semibold text-cyan-300">Narration</h4>
                                                    <p class="text-gray-300 whitespace-pre-wrap font-serif leading-relaxed">${scene.dialogue}</p>
                                                </div>
                                                <div class="mt-4 bg-gray-900/70 p-4 rounded-lg">
                                                    <h4 class="font-semibold text-gray-400">Visual Description</h4>
                                                    <p class="text-gray-400 text-sm italic">${scene.description_full}</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>`;
                    }
                    break;
            }

            appContainer.innerHTML = `
                ${loadingIndicator}
                <div class="container mx-auto p-4 md:p-8 pt-12">
                    ${header}
                    ${errorDisplay}
                    ${viewContent}
                </div>
            `;
            
            // Re-attach event listeners and set element values for controlled components
             if (state.view === 'final-selection') {
                const writingStyleSelect = document.getElementById('writing-style-select');
                if (writingStyleSelect) {
                    writingStyleSelect.value = state.writingStyle;
                    writingStyleSelect.onchange = (e) => setState({ writingStyle: e.target.value });
                }
                const aiImageStyleSelect = document.getElementById('ai-image-style-select');
                 if (aiImageStyleSelect) {
                    aiImageStyleSelect.value = state.aiImageStyle;
                    aiImageStyleSelect.onchange = (e) => setState({ aiImageStyle: e.target.value });
                 }
            }
             if (state.view === 'custom') {
                 const customTopicInput = document.getElementById('custom-topic-input');
                 if (customTopicInput) {
                     customTopicInput.onchange = (e) => setState({ customTopic: e.target.value });
                 }
             }

        }

        // Initial render
        render();

    </script>
</body>
</html>


